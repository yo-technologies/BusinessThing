package quota

import (
	"context"
	"time"

	"llm-service/internal/domain"

	"github.com/opentracing/opentracing-go"
)

// TokenLimitProvider allows customizing per-user token limits.
// If nil, default from config is used.
type TokenLimitProvider func(ctx context.Context, userID domain.ID) int

type repo interface {
	ReserveLLMTokens(ctx context.Context, userID domain.ID, day time.Time, n int, dailyLimit int) (bool, error)
	ConfirmLLMTokenUsage(ctx context.Context, userID domain.ID, day time.Time, reserved int, actual int) error
	GetLLMDailyUsage(ctx context.Context, userID domain.ID, day time.Time) (used int, reserved int, err error)
}

type Service struct {
	repo      repo
	limitProv TokenLimitProvider
}

func New(r repo, lp TokenLimitProvider) *Service {
	return &Service{repo: r, limitProv: lp}
}

func (s *Service) today() time.Time {
	now := time.Now().UTC()
	y, m, d := now.Date()
	return time.Date(y, m, d, 0, 0, 0, 0, time.UTC)
}

// Reserve reserves n tokens if within daily limit. Returns true if allowed.
func (s *Service) Reserve(ctx context.Context, userID domain.ID, n int) (bool, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "service.quota.Reserve")
	defer span.Finish()

	day := s.today()
	limit := s.limitProv(ctx, userID)
	return s.repo.ReserveLLMTokens(ctx, userID, day, n, limit)
}

// Confirm adjusts reserved and increments used by actual tokens consumed.
// If actual < reserved, the remainder is released. We don't enforce limit here strictly
// to avoid failing post-consumption; enforcement happens at Reserve time.
func (s *Service) Confirm(ctx context.Context, userID domain.ID, reserved int, actual int) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "service.quota.Confirm")
	defer span.Finish()

	day := s.today()
	return s.repo.ConfirmLLMTokenUsage(ctx, userID, day, reserved, actual)
}

// GetLLMDailyUsage возвращает использованные и зарезервированные токены на выбранный день
func (s *Service) GetLLMDailyUsage(ctx context.Context, userID domain.ID, day time.Time) (used int, reserved int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "service.quota.GetLLMDailyUsage")
	defer span.Finish()

	// нормализуем день к полуночи UTC
	d := time.Date(day.Year(), day.Month(), day.Day(), 0, 0, 0, 0, time.UTC)
	return s.repo.GetLLMDailyUsage(ctx, userID, d)
}

// DailyLimit сообщает актуальный дневной лимит токенов для пользователя
func (s *Service) DailyLimit(ctx context.Context, userID domain.ID) int {
	span, ctx := opentracing.StartSpanFromContext(ctx, "service.quota.DailyLimit")
	defer span.Finish()

	return s.limitProv(ctx, userID)
}

// GetLimits возвращает информацию о лимитах и использовании токенов
func (s *Service) GetLimits(ctx context.Context, userID domain.ID) (domain.LLMLimits, error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "service.quota.GetLimits")
	defer span.Finish()

	day := s.today()
	used, reserved, err := s.repo.GetLLMDailyUsage(ctx, userID, day)
	if err != nil {
		return domain.LLMLimits{}, err
	}

	limit := s.limitProv(ctx, userID)
	return domain.NewLLMLimits(limit, used, reserved), nil
}
