// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: core/core.proto

package core

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _core_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on AuthenticateWithTelegramRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticateWithTelegramRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticateWithTelegramRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AuthenticateWithTelegramRequestMultiError, or nil if none found.
func (m *AuthenticateWithTelegramRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticateWithTelegramRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInitData()) < 1 {
		err := AuthenticateWithTelegramRequestValidationError{
			field:  "InitData",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuthenticateWithTelegramRequestMultiError(errors)
	}

	return nil
}

// AuthenticateWithTelegramRequestMultiError is an error wrapping multiple
// validation errors returned by AuthenticateWithTelegramRequest.ValidateAll()
// if the designated constraints aren't met.
type AuthenticateWithTelegramRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticateWithTelegramRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticateWithTelegramRequestMultiError) AllErrors() []error { return m }

// AuthenticateWithTelegramRequestValidationError is the validation error
// returned by AuthenticateWithTelegramRequest.Validate if the designated
// constraints aren't met.
type AuthenticateWithTelegramRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticateWithTelegramRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticateWithTelegramRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticateWithTelegramRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticateWithTelegramRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticateWithTelegramRequestValidationError) ErrorName() string {
	return "AuthenticateWithTelegramRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticateWithTelegramRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticateWithTelegramRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticateWithTelegramRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticateWithTelegramRequestValidationError{}

// Validate checks the field values on AuthenticateWithTelegramResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *AuthenticateWithTelegramResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticateWithTelegramResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AuthenticateWithTelegramResponseMultiError, or nil if none found.
func (m *AuthenticateWithTelegramResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticateWithTelegramResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthenticateWithTelegramResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthenticateWithTelegramResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthenticateWithTelegramResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsNewUser

	if len(errors) > 0 {
		return AuthenticateWithTelegramResponseMultiError(errors)
	}

	return nil
}

// AuthenticateWithTelegramResponseMultiError is an error wrapping multiple
// validation errors returned by
// AuthenticateWithTelegramResponse.ValidateAll() if the designated
// constraints aren't met.
type AuthenticateWithTelegramResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticateWithTelegramResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticateWithTelegramResponseMultiError) AllErrors() []error { return m }

// AuthenticateWithTelegramResponseValidationError is the validation error
// returned by AuthenticateWithTelegramResponse.Validate if the designated
// constraints aren't met.
type AuthenticateWithTelegramResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticateWithTelegramResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticateWithTelegramResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticateWithTelegramResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticateWithTelegramResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticateWithTelegramResponseValidationError) ErrorName() string {
	return "AuthenticateWithTelegramResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticateWithTelegramResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticateWithTelegramResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticateWithTelegramResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticateWithTelegramResponseValidationError{}

// Validate checks the field values on CompleteRegistrationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteRegistrationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteRegistrationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteRegistrationRequestMultiError, or nil if none found.
func (m *CompleteRegistrationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteRegistrationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = CompleteRegistrationRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFirstName()); l < 1 || l > 100 {
		err := CompleteRegistrationRequestValidationError{
			field:  "FirstName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetLastName()); l < 1 || l > 100 {
		err := CompleteRegistrationRequestValidationError{
			field:  "LastName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CompleteRegistrationRequestMultiError(errors)
	}

	return nil
}

func (m *CompleteRegistrationRequest) _validateUuid(uuid string) error {
	if matched := _core_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CompleteRegistrationRequestMultiError is an error wrapping multiple
// validation errors returned by CompleteRegistrationRequest.ValidateAll() if
// the designated constraints aren't met.
type CompleteRegistrationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteRegistrationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteRegistrationRequestMultiError) AllErrors() []error { return m }

// CompleteRegistrationRequestValidationError is the validation error returned
// by CompleteRegistrationRequest.Validate if the designated constraints
// aren't met.
type CompleteRegistrationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteRegistrationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteRegistrationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteRegistrationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteRegistrationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteRegistrationRequestValidationError) ErrorName() string {
	return "CompleteRegistrationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteRegistrationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteRegistrationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteRegistrationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteRegistrationRequestValidationError{}

// Validate checks the field values on CompleteRegistrationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteRegistrationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteRegistrationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteRegistrationResponseMultiError, or nil if none found.
func (m *CompleteRegistrationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteRegistrationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompleteRegistrationResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompleteRegistrationResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompleteRegistrationResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompleteRegistrationResponseMultiError(errors)
	}

	return nil
}

// CompleteRegistrationResponseMultiError is an error wrapping multiple
// validation errors returned by CompleteRegistrationResponse.ValidateAll() if
// the designated constraints aren't met.
type CompleteRegistrationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteRegistrationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteRegistrationResponseMultiError) AllErrors() []error { return m }

// CompleteRegistrationResponseValidationError is the validation error returned
// by CompleteRegistrationResponse.Validate if the designated constraints
// aren't met.
type CompleteRegistrationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteRegistrationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteRegistrationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteRegistrationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteRegistrationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteRegistrationResponseValidationError) ErrorName() string {
	return "CompleteRegistrationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteRegistrationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteRegistrationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteRegistrationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteRegistrationResponseValidationError{}

// Validate checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenRequestMultiError, or nil if none found.
func (m *RefreshTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RefreshTokenRequestMultiError(errors)
	}

	return nil
}

// RefreshTokenRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenRequestMultiError) AllErrors() []error { return m }

// RefreshTokenRequestValidationError is the validation error returned by
// RefreshTokenRequest.Validate if the designated constraints aren't met.
type RefreshTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenRequestValidationError) ErrorName() string {
	return "RefreshTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenRequestValidationError{}

// Validate checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenResponseMultiError, or nil if none found.
func (m *RefreshTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return RefreshTokenResponseMultiError(errors)
	}

	return nil
}

// RefreshTokenResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenResponseMultiError) AllErrors() []error { return m }

// RefreshTokenResponseValidationError is the validation error returned by
// RefreshTokenResponse.Validate if the designated constraints aren't met.
type RefreshTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenResponseValidationError) ErrorName() string {
	return "RefreshTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenResponseValidationError{}

// Validate checks the field values on CreateOrganizationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrganizationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrganizationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrganizationRequestMultiError, or nil if none found.
func (m *CreateOrganizationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrganizationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 200 {
		err := CreateOrganizationRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Industry

	// no validation rules for Region

	// no validation rules for Description

	// no validation rules for ProfileData

	if len(errors) > 0 {
		return CreateOrganizationRequestMultiError(errors)
	}

	return nil
}

// CreateOrganizationRequestMultiError is an error wrapping multiple validation
// errors returned by CreateOrganizationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateOrganizationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrganizationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrganizationRequestMultiError) AllErrors() []error { return m }

// CreateOrganizationRequestValidationError is the validation error returned by
// CreateOrganizationRequest.Validate if the designated constraints aren't met.
type CreateOrganizationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrganizationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrganizationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrganizationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrganizationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrganizationRequestValidationError) ErrorName() string {
	return "CreateOrganizationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrganizationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrganizationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrganizationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrganizationRequestValidationError{}

// Validate checks the field values on CreateOrganizationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrganizationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrganizationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrganizationResponseMultiError, or nil if none found.
func (m *CreateOrganizationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrganizationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrganization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrganizationResponseValidationError{
				field:  "Organization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrganizationResponseMultiError(errors)
	}

	return nil
}

// CreateOrganizationResponseMultiError is an error wrapping multiple
// validation errors returned by CreateOrganizationResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateOrganizationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrganizationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrganizationResponseMultiError) AllErrors() []error { return m }

// CreateOrganizationResponseValidationError is the validation error returned
// by CreateOrganizationResponse.Validate if the designated constraints aren't met.
type CreateOrganizationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrganizationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrganizationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrganizationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrganizationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrganizationResponseValidationError) ErrorName() string {
	return "CreateOrganizationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrganizationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrganizationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrganizationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrganizationResponseValidationError{}

// Validate checks the field values on GetOrganizationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrganizationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrganizationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrganizationRequestMultiError, or nil if none found.
func (m *GetOrganizationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrganizationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetOrganizationRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetOrganizationRequestMultiError(errors)
	}

	return nil
}

// GetOrganizationRequestMultiError is an error wrapping multiple validation
// errors returned by GetOrganizationRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOrganizationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrganizationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrganizationRequestMultiError) AllErrors() []error { return m }

// GetOrganizationRequestValidationError is the validation error returned by
// GetOrganizationRequest.Validate if the designated constraints aren't met.
type GetOrganizationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrganizationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrganizationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrganizationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrganizationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrganizationRequestValidationError) ErrorName() string {
	return "GetOrganizationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrganizationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrganizationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrganizationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrganizationRequestValidationError{}

// Validate checks the field values on GetOrganizationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrganizationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrganizationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrganizationResponseMultiError, or nil if none found.
func (m *GetOrganizationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrganizationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrganization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrganizationResponseValidationError{
				field:  "Organization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOrganizationResponseMultiError(errors)
	}

	return nil
}

// GetOrganizationResponseMultiError is an error wrapping multiple validation
// errors returned by GetOrganizationResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOrganizationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrganizationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrganizationResponseMultiError) AllErrors() []error { return m }

// GetOrganizationResponseValidationError is the validation error returned by
// GetOrganizationResponse.Validate if the designated constraints aren't met.
type GetOrganizationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrganizationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrganizationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrganizationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrganizationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrganizationResponseValidationError) ErrorName() string {
	return "GetOrganizationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrganizationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrganizationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrganizationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrganizationResponseValidationError{}

// Validate checks the field values on ListMyOrganizationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMyOrganizationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMyOrganizationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMyOrganizationsRequestMultiError, or nil if none found.
func (m *ListMyOrganizationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMyOrganizationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListMyOrganizationsRequestMultiError(errors)
	}

	return nil
}

// ListMyOrganizationsRequestMultiError is an error wrapping multiple
// validation errors returned by ListMyOrganizationsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListMyOrganizationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMyOrganizationsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMyOrganizationsRequestMultiError) AllErrors() []error { return m }

// ListMyOrganizationsRequestValidationError is the validation error returned
// by ListMyOrganizationsRequest.Validate if the designated constraints aren't met.
type ListMyOrganizationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMyOrganizationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMyOrganizationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMyOrganizationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMyOrganizationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMyOrganizationsRequestValidationError) ErrorName() string {
	return "ListMyOrganizationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMyOrganizationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMyOrganizationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMyOrganizationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMyOrganizationsRequestValidationError{}

// Validate checks the field values on ListMyOrganizationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMyOrganizationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMyOrganizationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMyOrganizationsResponseMultiError, or nil if none found.
func (m *ListMyOrganizationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMyOrganizationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOrganizations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMyOrganizationsResponseValidationError{
						field:  fmt.Sprintf("Organizations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMyOrganizationsResponseValidationError{
						field:  fmt.Sprintf("Organizations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMyOrganizationsResponseValidationError{
					field:  fmt.Sprintf("Organizations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMyOrganizationsResponseMultiError(errors)
	}

	return nil
}

// ListMyOrganizationsResponseMultiError is an error wrapping multiple
// validation errors returned by ListMyOrganizationsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListMyOrganizationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMyOrganizationsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMyOrganizationsResponseMultiError) AllErrors() []error { return m }

// ListMyOrganizationsResponseValidationError is the validation error returned
// by ListMyOrganizationsResponse.Validate if the designated constraints
// aren't met.
type ListMyOrganizationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMyOrganizationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMyOrganizationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMyOrganizationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMyOrganizationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMyOrganizationsResponseValidationError) ErrorName() string {
	return "ListMyOrganizationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMyOrganizationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMyOrganizationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMyOrganizationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMyOrganizationsResponseValidationError{}

// Validate checks the field values on UpdateOrganizationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOrganizationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrganizationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOrganizationRequestMultiError, or nil if none found.
func (m *UpdateOrganizationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrganizationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateOrganizationRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Industry != nil {
		// no validation rules for Industry
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.ProfileData != nil {
		// no validation rules for ProfileData
	}

	if len(errors) > 0 {
		return UpdateOrganizationRequestMultiError(errors)
	}

	return nil
}

// UpdateOrganizationRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateOrganizationRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateOrganizationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrganizationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrganizationRequestMultiError) AllErrors() []error { return m }

// UpdateOrganizationRequestValidationError is the validation error returned by
// UpdateOrganizationRequest.Validate if the designated constraints aren't met.
type UpdateOrganizationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrganizationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrganizationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrganizationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrganizationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrganizationRequestValidationError) ErrorName() string {
	return "UpdateOrganizationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOrganizationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrganizationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrganizationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrganizationRequestValidationError{}

// Validate checks the field values on UpdateOrganizationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOrganizationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrganizationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOrganizationResponseMultiError, or nil if none found.
func (m *UpdateOrganizationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrganizationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrganization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOrganizationResponseValidationError{
					field:  "Organization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOrganizationResponseValidationError{
				field:  "Organization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateOrganizationResponseMultiError(errors)
	}

	return nil
}

// UpdateOrganizationResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateOrganizationResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateOrganizationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrganizationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrganizationResponseMultiError) AllErrors() []error { return m }

// UpdateOrganizationResponseValidationError is the validation error returned
// by UpdateOrganizationResponse.Validate if the designated constraints aren't met.
type UpdateOrganizationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrganizationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrganizationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrganizationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrganizationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrganizationResponseValidationError) ErrorName() string {
	return "UpdateOrganizationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOrganizationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrganizationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrganizationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrganizationResponseValidationError{}

// Validate checks the field values on DeleteOrganizationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteOrganizationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteOrganizationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteOrganizationRequestMultiError, or nil if none found.
func (m *DeleteOrganizationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteOrganizationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteOrganizationRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteOrganizationRequestMultiError(errors)
	}

	return nil
}

// DeleteOrganizationRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteOrganizationRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteOrganizationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteOrganizationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteOrganizationRequestMultiError) AllErrors() []error { return m }

// DeleteOrganizationRequestValidationError is the validation error returned by
// DeleteOrganizationRequest.Validate if the designated constraints aren't met.
type DeleteOrganizationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteOrganizationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteOrganizationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteOrganizationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteOrganizationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteOrganizationRequestValidationError) ErrorName() string {
	return "DeleteOrganizationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteOrganizationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteOrganizationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteOrganizationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteOrganizationRequestValidationError{}

// Validate checks the field values on InviteUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InviteUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InviteUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InviteUserRequestMultiError, or nil if none found.
func (m *InviteUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InviteUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := InviteUserRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := UserRole_name[int32(m.GetRole())]; !ok {
		err := InviteUserRequestValidationError{
			field:  "Role",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InviteUserRequestMultiError(errors)
	}

	return nil
}

// InviteUserRequestMultiError is an error wrapping multiple validation errors
// returned by InviteUserRequest.ValidateAll() if the designated constraints
// aren't met.
type InviteUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InviteUserRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InviteUserRequestMultiError) AllErrors() []error { return m }

// InviteUserRequestValidationError is the validation error returned by
// InviteUserRequest.Validate if the designated constraints aren't met.
type InviteUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InviteUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InviteUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InviteUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InviteUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InviteUserRequestValidationError) ErrorName() string {
	return "InviteUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InviteUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInviteUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InviteUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InviteUserRequestValidationError{}

// Validate checks the field values on InviteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InviteUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InviteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InviteUserResponseMultiError, or nil if none found.
func (m *InviteUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InviteUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InvitationToken

	// no validation rules for InvitationUrl

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InviteUserResponseValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InviteUserResponseValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InviteUserResponseValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InviteUserResponseMultiError(errors)
	}

	return nil
}

// InviteUserResponseMultiError is an error wrapping multiple validation errors
// returned by InviteUserResponse.ValidateAll() if the designated constraints
// aren't met.
type InviteUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InviteUserResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InviteUserResponseMultiError) AllErrors() []error { return m }

// InviteUserResponseValidationError is the validation error returned by
// InviteUserResponse.Validate if the designated constraints aren't met.
type InviteUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InviteUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InviteUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InviteUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InviteUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InviteUserResponseValidationError) ErrorName() string {
	return "InviteUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InviteUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInviteUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InviteUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InviteUserResponseValidationError{}

// Validate checks the field values on AcceptInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AcceptInvitationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AcceptInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AcceptInvitationRequestMultiError, or nil if none found.
func (m *AcceptInvitationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AcceptInvitationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetToken()) < 1 {
		err := AcceptInvitationRequestValidationError{
			field:  "Token",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AcceptInvitationRequestMultiError(errors)
	}

	return nil
}

// AcceptInvitationRequestMultiError is an error wrapping multiple validation
// errors returned by AcceptInvitationRequest.ValidateAll() if the designated
// constraints aren't met.
type AcceptInvitationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcceptInvitationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AcceptInvitationRequestMultiError) AllErrors() []error { return m }

// AcceptInvitationRequestValidationError is the validation error returned by
// AcceptInvitationRequest.Validate if the designated constraints aren't met.
type AcceptInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AcceptInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AcceptInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AcceptInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AcceptInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AcceptInvitationRequestValidationError) ErrorName() string {
	return "AcceptInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AcceptInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAcceptInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AcceptInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AcceptInvitationRequestValidationError{}

// Validate checks the field values on AcceptInvitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AcceptInvitationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AcceptInvitationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AcceptInvitationResponseMultiError, or nil if none found.
func (m *AcceptInvitationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AcceptInvitationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AcceptInvitationResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AcceptInvitationResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AcceptInvitationResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AcceptInvitationResponseMultiError(errors)
	}

	return nil
}

// AcceptInvitationResponseMultiError is an error wrapping multiple validation
// errors returned by AcceptInvitationResponse.ValidateAll() if the designated
// constraints aren't met.
type AcceptInvitationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcceptInvitationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AcceptInvitationResponseMultiError) AllErrors() []error { return m }

// AcceptInvitationResponseValidationError is the validation error returned by
// AcceptInvitationResponse.Validate if the designated constraints aren't met.
type AcceptInvitationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AcceptInvitationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AcceptInvitationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AcceptInvitationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AcceptInvitationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AcceptInvitationResponseValidationError) ErrorName() string {
	return "AcceptInvitationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AcceptInvitationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAcceptInvitationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AcceptInvitationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AcceptInvitationResponseValidationError{}

// Validate checks the field values on ListUsersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersRequestMultiError, or nil if none found.
func (m *ListUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListUsersRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListUsersRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUsersRequestMultiError(errors)
	}

	return nil
}

// ListUsersRequestMultiError is an error wrapping multiple validation errors
// returned by ListUsersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersRequestMultiError) AllErrors() []error { return m }

// ListUsersRequestValidationError is the validation error returned by
// ListUsersRequest.Validate if the designated constraints aren't met.
type ListUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersRequestValidationError) ErrorName() string { return "ListUsersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersRequestValidationError{}

// Validate checks the field values on ListUsersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersResponseMultiError, or nil if none found.
func (m *ListUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUsersResponseValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListUsersResponseMultiError(errors)
	}

	return nil
}

// ListUsersResponseMultiError is an error wrapping multiple validation errors
// returned by ListUsersResponse.ValidateAll() if the designated constraints
// aren't met.
type ListUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersResponseMultiError) AllErrors() []error { return m }

// ListUsersResponseValidationError is the validation error returned by
// ListUsersResponse.Validate if the designated constraints aren't met.
type ListUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersResponseValidationError) ErrorName() string {
	return "ListUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersResponseValidationError{}

// Validate checks the field values on GetUserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserRequestMultiError,
// or nil if none found.
func (m *GetUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetUserRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserRequestMultiError(errors)
	}

	return nil
}

// GetUserRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserRequestMultiError) AllErrors() []error { return m }

// GetUserRequestValidationError is the validation error returned by
// GetUserRequest.Validate if the designated constraints aren't met.
type GetUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserRequestValidationError) ErrorName() string { return "GetUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserRequestValidationError{}

// Validate checks the field values on GetUserResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserResponseMultiError, or nil if none found.
func (m *GetUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserResponseMultiError(errors)
	}

	return nil
}

// GetUserResponseMultiError is an error wrapping multiple validation errors
// returned by GetUserResponse.ValidateAll() if the designated constraints
// aren't met.
type GetUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserResponseMultiError) AllErrors() []error { return m }

// GetUserResponseValidationError is the validation error returned by
// GetUserResponse.Validate if the designated constraints aren't met.
type GetUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserResponseValidationError) ErrorName() string { return "GetUserResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserResponseValidationError{}

// Validate checks the field values on UpdateUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRoleRequestMultiError, or nil if none found.
func (m *UpdateUserRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateUserRoleRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := UserRole_name[int32(m.GetRole())]; !ok {
		err := UpdateUserRoleRequestValidationError{
			field:  "Role",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateUserRoleRequestMultiError(errors)
	}

	return nil
}

// UpdateUserRoleRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateUserRoleRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRoleRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRoleRequestMultiError) AllErrors() []error { return m }

// UpdateUserRoleRequestValidationError is the validation error returned by
// UpdateUserRoleRequest.Validate if the designated constraints aren't met.
type UpdateUserRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRoleRequestValidationError) ErrorName() string {
	return "UpdateUserRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRoleRequestValidationError{}

// Validate checks the field values on UpdateUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRoleResponseMultiError, or nil if none found.
func (m *UpdateUserRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserRoleResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserRoleResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRoleResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserRoleResponseMultiError(errors)
	}

	return nil
}

// UpdateUserRoleResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateUserRoleResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRoleResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRoleResponseMultiError) AllErrors() []error { return m }

// UpdateUserRoleResponseValidationError is the validation error returned by
// UpdateUserRoleResponse.Validate if the designated constraints aren't met.
type UpdateUserRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRoleResponseValidationError) ErrorName() string {
	return "UpdateUserRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRoleResponseValidationError{}

// Validate checks the field values on DeactivateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateUserRequestMultiError, or nil if none found.
func (m *DeactivateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = DeactivateUserRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeactivateUserRequestMultiError(errors)
	}

	return nil
}

func (m *DeactivateUserRequest) _validateUuid(uuid string) error {
	if matched := _core_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeactivateUserRequestMultiError is an error wrapping multiple validation
// errors returned by DeactivateUserRequest.ValidateAll() if the designated
// constraints aren't met.
type DeactivateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateUserRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateUserRequestMultiError) AllErrors() []error { return m }

// DeactivateUserRequestValidationError is the validation error returned by
// DeactivateUserRequest.Validate if the designated constraints aren't met.
type DeactivateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateUserRequestValidationError) ErrorName() string {
	return "DeactivateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateUserRequestValidationError{}

// Validate checks the field values on ListInvitationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInvitationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInvitationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInvitationsRequestMultiError, or nil if none found.
func (m *ListInvitationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInvitationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListInvitationsRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListInvitationsRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListInvitationsRequestMultiError(errors)
	}

	return nil
}

// ListInvitationsRequestMultiError is an error wrapping multiple validation
// errors returned by ListInvitationsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListInvitationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInvitationsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInvitationsRequestMultiError) AllErrors() []error { return m }

// ListInvitationsRequestValidationError is the validation error returned by
// ListInvitationsRequest.Validate if the designated constraints aren't met.
type ListInvitationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInvitationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInvitationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInvitationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInvitationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInvitationsRequestValidationError) ErrorName() string {
	return "ListInvitationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInvitationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInvitationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInvitationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInvitationsRequestValidationError{}

// Validate checks the field values on ListInvitationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInvitationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInvitationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInvitationsResponseMultiError, or nil if none found.
func (m *ListInvitationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInvitationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvitations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListInvitationsResponseValidationError{
						field:  fmt.Sprintf("Invitations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListInvitationsResponseValidationError{
						field:  fmt.Sprintf("Invitations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListInvitationsResponseValidationError{
					field:  fmt.Sprintf("Invitations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	if len(errors) > 0 {
		return ListInvitationsResponseMultiError(errors)
	}

	return nil
}

// ListInvitationsResponseMultiError is an error wrapping multiple validation
// errors returned by ListInvitationsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListInvitationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInvitationsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInvitationsResponseMultiError) AllErrors() []error { return m }

// ListInvitationsResponseValidationError is the validation error returned by
// ListInvitationsResponse.Validate if the designated constraints aren't met.
type ListInvitationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInvitationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInvitationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInvitationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInvitationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInvitationsResponseValidationError) ErrorName() string {
	return "ListInvitationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListInvitationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInvitationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInvitationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInvitationsResponseValidationError{}

// Validate checks the field values on Invitation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invitation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invitation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvitationMultiError, or
// nil if none found.
func (m *Invitation) ValidateAll() error {
	return m.validate(true)
}

func (m *Invitation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for Token

	// no validation rules for Role

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "UsedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "UsedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "UsedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvitationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvitationMultiError(errors)
	}

	return nil
}

// InvitationMultiError is an error wrapping multiple validation errors
// returned by Invitation.ValidateAll() if the designated constraints aren't met.
type InvitationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvitationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvitationMultiError) AllErrors() []error { return m }

// InvitationValidationError is the validation error returned by
// Invitation.Validate if the designated constraints aren't met.
type InvitationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationValidationError) ErrorName() string { return "InvitationValidationError" }

// Error satisfies the builtin error interface
func (e InvitationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationValidationError{}

// Validate checks the field values on RegisterDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterDocumentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterDocumentRequestMultiError, or nil if none found.
func (m *RegisterDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := RegisterDocumentRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := RegisterDocumentRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetS3Key()) < 1 {
		err := RegisterDocumentRequestValidationError{
			field:  "S3Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FileType

	// no validation rules for FileSize

	if len(errors) > 0 {
		return RegisterDocumentRequestMultiError(errors)
	}

	return nil
}

// RegisterDocumentRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterDocumentRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterDocumentRequestMultiError) AllErrors() []error { return m }

// RegisterDocumentRequestValidationError is the validation error returned by
// RegisterDocumentRequest.Validate if the designated constraints aren't met.
type RegisterDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterDocumentRequestValidationError) ErrorName() string {
	return "RegisterDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterDocumentRequestValidationError{}

// Validate checks the field values on RegisterDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterDocumentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterDocumentResponseMultiError, or nil if none found.
func (m *RegisterDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterDocumentResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterDocumentResponseMultiError(errors)
	}

	return nil
}

// RegisterDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterDocumentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterDocumentResponseMultiError) AllErrors() []error { return m }

// RegisterDocumentResponseValidationError is the validation error returned by
// RegisterDocumentResponse.Validate if the designated constraints aren't met.
type RegisterDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterDocumentResponseValidationError) ErrorName() string {
	return "RegisterDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterDocumentResponseValidationError{}

// Validate checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentRequestMultiError, or nil if none found.
func (m *GetDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetDocumentRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDocumentRequestMultiError(errors)
	}

	return nil
}

// GetDocumentRequestMultiError is an error wrapping multiple validation errors
// returned by GetDocumentRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentRequestMultiError) AllErrors() []error { return m }

// GetDocumentRequestValidationError is the validation error returned by
// GetDocumentRequest.Validate if the designated constraints aren't met.
type GetDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentRequestValidationError) ErrorName() string {
	return "GetDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentRequestValidationError{}

// Validate checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentResponseMultiError, or nil if none found.
func (m *GetDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDocumentResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDocumentResponseMultiError(errors)
	}

	return nil
}

// GetDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by GetDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentResponseMultiError) AllErrors() []error { return m }

// GetDocumentResponseValidationError is the validation error returned by
// GetDocumentResponse.Validate if the designated constraints aren't met.
type GetDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentResponseValidationError) ErrorName() string {
	return "GetDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentResponseValidationError{}

// Validate checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsRequestMultiError, or nil if none found.
func (m *ListDocumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListDocumentsRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListDocumentsRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if len(errors) > 0 {
		return ListDocumentsRequestMultiError(errors)
	}

	return nil
}

// ListDocumentsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsRequestMultiError) AllErrors() []error { return m }

// ListDocumentsRequestValidationError is the validation error returned by
// ListDocumentsRequest.Validate if the designated constraints aren't met.
type ListDocumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsRequestValidationError) ErrorName() string {
	return "ListDocumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsRequestValidationError{}

// Validate checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsResponseMultiError, or nil if none found.
func (m *ListDocumentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDocuments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDocumentsResponseValidationError{
					field:  fmt.Sprintf("Documents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListDocumentsResponseMultiError(errors)
	}

	return nil
}

// ListDocumentsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsResponseMultiError) AllErrors() []error { return m }

// ListDocumentsResponseValidationError is the validation error returned by
// ListDocumentsResponse.Validate if the designated constraints aren't met.
type ListDocumentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsResponseValidationError) ErrorName() string {
	return "ListDocumentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsResponseValidationError{}

// Validate checks the field values on UpdateDocumentStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDocumentStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDocumentStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDocumentStatusRequestMultiError, or nil if none found.
func (m *UpdateDocumentStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDocumentStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateDocumentStatusRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := DocumentStatus_name[int32(m.GetStatus())]; !ok {
		err := UpdateDocumentStatusRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ErrorMessage != nil {
		// no validation rules for ErrorMessage
	}

	if len(errors) > 0 {
		return UpdateDocumentStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateDocumentStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDocumentStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDocumentStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDocumentStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDocumentStatusRequestMultiError) AllErrors() []error { return m }

// UpdateDocumentStatusRequestValidationError is the validation error returned
// by UpdateDocumentStatusRequest.Validate if the designated constraints
// aren't met.
type UpdateDocumentStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDocumentStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDocumentStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDocumentStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDocumentStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDocumentStatusRequestValidationError) ErrorName() string {
	return "UpdateDocumentStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDocumentStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDocumentStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDocumentStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDocumentStatusRequestValidationError{}

// Validate checks the field values on DeleteDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDocumentRequestMultiError, or nil if none found.
func (m *DeleteDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteDocumentRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDocumentRequestMultiError(errors)
	}

	return nil
}

// DeleteDocumentRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDocumentRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDocumentRequestMultiError) AllErrors() []error { return m }

// DeleteDocumentRequestValidationError is the validation error returned by
// DeleteDocumentRequest.Validate if the designated constraints aren't met.
type DeleteDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDocumentRequestValidationError) ErrorName() string {
	return "DeleteDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDocumentRequestValidationError{}

// Validate checks the field values on CreateNoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateNoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNoteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNoteRequestMultiError, or nil if none found.
func (m *CreateNoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := CreateNoteRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetContent()); l < 1 || l > 1000 {
		err := CreateNoteRequestValidationError{
			field:  "Content",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateNoteRequestMultiError(errors)
	}

	return nil
}

// CreateNoteRequestMultiError is an error wrapping multiple validation errors
// returned by CreateNoteRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateNoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNoteRequestMultiError) AllErrors() []error { return m }

// CreateNoteRequestValidationError is the validation error returned by
// CreateNoteRequest.Validate if the designated constraints aren't met.
type CreateNoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNoteRequestValidationError) ErrorName() string {
	return "CreateNoteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNoteRequestValidationError{}

// Validate checks the field values on CreateNoteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNoteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNoteResponseMultiError, or nil if none found.
func (m *CreateNoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNoteResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNoteResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNoteResponseValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNoteResponseMultiError(errors)
	}

	return nil
}

// CreateNoteResponseMultiError is an error wrapping multiple validation errors
// returned by CreateNoteResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateNoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNoteResponseMultiError) AllErrors() []error { return m }

// CreateNoteResponseValidationError is the validation error returned by
// CreateNoteResponse.Validate if the designated constraints aren't met.
type CreateNoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNoteResponseValidationError) ErrorName() string {
	return "CreateNoteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNoteResponseValidationError{}

// Validate checks the field values on ListNotesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListNotesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNotesRequestMultiError, or nil if none found.
func (m *ListNotesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListNotesRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 1 || val > 100 {
		err := ListNotesRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListNotesRequestMultiError(errors)
	}

	return nil
}

// ListNotesRequestMultiError is an error wrapping multiple validation errors
// returned by ListNotesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListNotesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotesRequestMultiError) AllErrors() []error { return m }

// ListNotesRequestValidationError is the validation error returned by
// ListNotesRequest.Validate if the designated constraints aren't met.
type ListNotesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotesRequestValidationError) ErrorName() string { return "ListNotesRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListNotesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotesRequestValidationError{}

// Validate checks the field values on ListNotesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListNotesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListNotesResponseMultiError, or nil if none found.
func (m *ListNotesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNotesResponseValidationError{
					field:  fmt.Sprintf("Notes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNotesResponseMultiError(errors)
	}

	return nil
}

// ListNotesResponseMultiError is an error wrapping multiple validation errors
// returned by ListNotesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListNotesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotesResponseMultiError) AllErrors() []error { return m }

// ListNotesResponseValidationError is the validation error returned by
// ListNotesResponse.Validate if the designated constraints aren't met.
type ListNotesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotesResponseValidationError) ErrorName() string {
	return "ListNotesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNotesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotesResponseValidationError{}

// Validate checks the field values on GetNoteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetNoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetNoteRequestMultiError,
// or nil if none found.
func (m *GetNoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetNoteRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNoteRequestMultiError(errors)
	}

	return nil
}

// GetNoteRequestMultiError is an error wrapping multiple validation errors
// returned by GetNoteRequest.ValidateAll() if the designated constraints
// aren't met.
type GetNoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteRequestMultiError) AllErrors() []error { return m }

// GetNoteRequestValidationError is the validation error returned by
// GetNoteRequest.Validate if the designated constraints aren't met.
type GetNoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteRequestValidationError) ErrorName() string { return "GetNoteRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetNoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteRequestValidationError{}

// Validate checks the field values on GetNoteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetNoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNoteResponseMultiError, or nil if none found.
func (m *GetNoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNoteResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNoteResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNoteResponseValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNoteResponseMultiError(errors)
	}

	return nil
}

// GetNoteResponseMultiError is an error wrapping multiple validation errors
// returned by GetNoteResponse.ValidateAll() if the designated constraints
// aren't met.
type GetNoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteResponseMultiError) AllErrors() []error { return m }

// GetNoteResponseValidationError is the validation error returned by
// GetNoteResponse.Validate if the designated constraints aren't met.
type GetNoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteResponseValidationError) ErrorName() string { return "GetNoteResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetNoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteResponseValidationError{}

// Validate checks the field values on DeleteNoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteNoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNoteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteNoteRequestMultiError, or nil if none found.
func (m *DeleteNoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteNoteRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNoteRequestMultiError(errors)
	}

	return nil
}

// DeleteNoteRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteNoteRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteNoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteRequestMultiError) AllErrors() []error { return m }

// DeleteNoteRequestValidationError is the validation error returned by
// DeleteNoteRequest.Validate if the designated constraints aren't met.
type DeleteNoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteRequestValidationError) ErrorName() string {
	return "DeleteNoteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteRequestValidationError{}

// Validate checks the field values on CreateTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTemplateRequestMultiError, or nil if none found.
func (m *CreateTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := CreateTemplateRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 200 {
		err := CreateTemplateRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for TemplateType

	// no validation rules for FieldsSchema

	// no validation rules for S3TemplateKey

	if len(errors) > 0 {
		return CreateTemplateRequestMultiError(errors)
	}

	return nil
}

// CreateTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTemplateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTemplateRequestMultiError) AllErrors() []error { return m }

// CreateTemplateRequestValidationError is the validation error returned by
// CreateTemplateRequest.Validate if the designated constraints aren't met.
type CreateTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTemplateRequestValidationError) ErrorName() string {
	return "CreateTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTemplateRequestValidationError{}

// Validate checks the field values on CreateTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTemplateResponseMultiError, or nil if none found.
func (m *CreateTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTemplateResponseValidationError{
				field:  "Template",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTemplateResponseMultiError(errors)
	}

	return nil
}

// CreateTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTemplateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTemplateResponseMultiError) AllErrors() []error { return m }

// CreateTemplateResponseValidationError is the validation error returned by
// CreateTemplateResponse.Validate if the designated constraints aren't met.
type CreateTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTemplateResponseValidationError) ErrorName() string {
	return "CreateTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTemplateResponseValidationError{}

// Validate checks the field values on GetTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTemplateRequestMultiError, or nil if none found.
func (m *GetTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetTemplateRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTemplateRequestMultiError(errors)
	}

	return nil
}

// GetTemplateRequestMultiError is an error wrapping multiple validation errors
// returned by GetTemplateRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTemplateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTemplateRequestMultiError) AllErrors() []error { return m }

// GetTemplateRequestValidationError is the validation error returned by
// GetTemplateRequest.Validate if the designated constraints aren't met.
type GetTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTemplateRequestValidationError) ErrorName() string {
	return "GetTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTemplateRequestValidationError{}

// Validate checks the field values on GetTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTemplateResponseMultiError, or nil if none found.
func (m *GetTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTemplateResponseValidationError{
				field:  "Template",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTemplateResponseMultiError(errors)
	}

	return nil
}

// GetTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by GetTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTemplateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTemplateResponseMultiError) AllErrors() []error { return m }

// GetTemplateResponseValidationError is the validation error returned by
// GetTemplateResponse.Validate if the designated constraints aren't met.
type GetTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTemplateResponseValidationError) ErrorName() string {
	return "GetTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTemplateResponseValidationError{}

// Validate checks the field values on ListTemplatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTemplatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTemplatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTemplatesRequestMultiError, or nil if none found.
func (m *ListTemplatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTemplatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListTemplatesRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListTemplatesRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTemplatesRequestMultiError(errors)
	}

	return nil
}

// ListTemplatesRequestMultiError is an error wrapping multiple validation
// errors returned by ListTemplatesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTemplatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTemplatesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTemplatesRequestMultiError) AllErrors() []error { return m }

// ListTemplatesRequestValidationError is the validation error returned by
// ListTemplatesRequest.Validate if the designated constraints aren't met.
type ListTemplatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTemplatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTemplatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTemplatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTemplatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTemplatesRequestValidationError) ErrorName() string {
	return "ListTemplatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTemplatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTemplatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTemplatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTemplatesRequestValidationError{}

// Validate checks the field values on ListTemplatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTemplatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTemplatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTemplatesResponseMultiError, or nil if none found.
func (m *ListTemplatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTemplatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTemplatesResponseValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTemplatesResponseValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTemplatesResponseValidationError{
					field:  fmt.Sprintf("Templates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListTemplatesResponseMultiError(errors)
	}

	return nil
}

// ListTemplatesResponseMultiError is an error wrapping multiple validation
// errors returned by ListTemplatesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTemplatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTemplatesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTemplatesResponseMultiError) AllErrors() []error { return m }

// ListTemplatesResponseValidationError is the validation error returned by
// ListTemplatesResponse.Validate if the designated constraints aren't met.
type ListTemplatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTemplatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTemplatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTemplatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTemplatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTemplatesResponseValidationError) ErrorName() string {
	return "ListTemplatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTemplatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTemplatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTemplatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTemplatesResponseValidationError{}

// Validate checks the field values on UpdateTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTemplateRequestMultiError, or nil if none found.
func (m *UpdateTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateTemplateRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.FieldsSchema != nil {
		// no validation rules for FieldsSchema
	}

	if m.S3TemplateKey != nil {
		// no validation rules for S3TemplateKey
	}

	if len(errors) > 0 {
		return UpdateTemplateRequestMultiError(errors)
	}

	return nil
}

// UpdateTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTemplateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTemplateRequestMultiError) AllErrors() []error { return m }

// UpdateTemplateRequestValidationError is the validation error returned by
// UpdateTemplateRequest.Validate if the designated constraints aren't met.
type UpdateTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTemplateRequestValidationError) ErrorName() string {
	return "UpdateTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTemplateRequestValidationError{}

// Validate checks the field values on UpdateTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTemplateResponseMultiError, or nil if none found.
func (m *UpdateTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTemplateResponseValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTemplateResponseValidationError{
				field:  "Template",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTemplateResponseMultiError(errors)
	}

	return nil
}

// UpdateTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTemplateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTemplateResponseMultiError) AllErrors() []error { return m }

// UpdateTemplateResponseValidationError is the validation error returned by
// UpdateTemplateResponse.Validate if the designated constraints aren't met.
type UpdateTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTemplateResponseValidationError) ErrorName() string {
	return "UpdateTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTemplateResponseValidationError{}

// Validate checks the field values on DeleteTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTemplateRequestMultiError, or nil if none found.
func (m *DeleteTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteTemplateRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTemplateRequestMultiError(errors)
	}

	return nil
}

// DeleteTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTemplateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTemplateRequestMultiError) AllErrors() []error { return m }

// DeleteTemplateRequestValidationError is the validation error returned by
// DeleteTemplateRequest.Validate if the designated constraints aren't met.
type DeleteTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTemplateRequestValidationError) ErrorName() string {
	return "DeleteTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTemplateRequestValidationError{}

// Validate checks the field values on RegisterContractRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterContractRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterContractRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterContractRequestMultiError, or nil if none found.
func (m *RegisterContractRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterContractRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := RegisterContractRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTemplateId()) < 1 {
		err := RegisterContractRequestValidationError{
			field:  "TemplateId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := RegisterContractRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FilledData

	if utf8.RuneCountInString(m.GetS3Key()) < 1 {
		err := RegisterContractRequestValidationError{
			field:  "S3Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FileType

	if len(errors) > 0 {
		return RegisterContractRequestMultiError(errors)
	}

	return nil
}

// RegisterContractRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterContractRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterContractRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterContractRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterContractRequestMultiError) AllErrors() []error { return m }

// RegisterContractRequestValidationError is the validation error returned by
// RegisterContractRequest.Validate if the designated constraints aren't met.
type RegisterContractRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterContractRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterContractRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterContractRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterContractRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterContractRequestValidationError) ErrorName() string {
	return "RegisterContractRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterContractRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterContractRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterContractRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterContractRequestValidationError{}

// Validate checks the field values on RegisterContractResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterContractResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterContractResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterContractResponseMultiError, or nil if none found.
func (m *RegisterContractResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterContractResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterContractResponseValidationError{
					field:  "Contract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterContractResponseValidationError{
					field:  "Contract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterContractResponseValidationError{
				field:  "Contract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterContractResponseMultiError(errors)
	}

	return nil
}

// RegisterContractResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterContractResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterContractResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterContractResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterContractResponseMultiError) AllErrors() []error { return m }

// RegisterContractResponseValidationError is the validation error returned by
// RegisterContractResponse.Validate if the designated constraints aren't met.
type RegisterContractResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterContractResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterContractResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterContractResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterContractResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterContractResponseValidationError) ErrorName() string {
	return "RegisterContractResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterContractResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterContractResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterContractResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterContractResponseValidationError{}

// Validate checks the field values on GetContractRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContractRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContractRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContractRequestMultiError, or nil if none found.
func (m *GetContractRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContractRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetContractRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetContractRequestMultiError(errors)
	}

	return nil
}

// GetContractRequestMultiError is an error wrapping multiple validation errors
// returned by GetContractRequest.ValidateAll() if the designated constraints
// aren't met.
type GetContractRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContractRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContractRequestMultiError) AllErrors() []error { return m }

// GetContractRequestValidationError is the validation error returned by
// GetContractRequest.Validate if the designated constraints aren't met.
type GetContractRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContractRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContractRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContractRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContractRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContractRequestValidationError) ErrorName() string {
	return "GetContractRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetContractRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContractRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContractRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContractRequestValidationError{}

// Validate checks the field values on GetContractResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContractResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContractResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContractResponseMultiError, or nil if none found.
func (m *GetContractResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContractResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetContractResponseValidationError{
					field:  "Contract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetContractResponseValidationError{
					field:  "Contract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetContractResponseValidationError{
				field:  "Contract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetContractResponseMultiError(errors)
	}

	return nil
}

// GetContractResponseMultiError is an error wrapping multiple validation
// errors returned by GetContractResponse.ValidateAll() if the designated
// constraints aren't met.
type GetContractResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContractResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContractResponseMultiError) AllErrors() []error { return m }

// GetContractResponseValidationError is the validation error returned by
// GetContractResponse.Validate if the designated constraints aren't met.
type GetContractResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContractResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContractResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContractResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContractResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContractResponseValidationError) ErrorName() string {
	return "GetContractResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetContractResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContractResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContractResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContractResponseValidationError{}

// Validate checks the field values on ListContractsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListContractsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListContractsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListContractsRequestMultiError, or nil if none found.
func (m *ListContractsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListContractsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := ListContractsRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListContractsRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListContractsRequestMultiError(errors)
	}

	return nil
}

// ListContractsRequestMultiError is an error wrapping multiple validation
// errors returned by ListContractsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListContractsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListContractsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListContractsRequestMultiError) AllErrors() []error { return m }

// ListContractsRequestValidationError is the validation error returned by
// ListContractsRequest.Validate if the designated constraints aren't met.
type ListContractsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListContractsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListContractsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListContractsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListContractsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListContractsRequestValidationError) ErrorName() string {
	return "ListContractsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListContractsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListContractsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListContractsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListContractsRequestValidationError{}

// Validate checks the field values on ListContractsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListContractsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListContractsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListContractsResponseMultiError, or nil if none found.
func (m *ListContractsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListContractsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetContracts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListContractsResponseValidationError{
						field:  fmt.Sprintf("Contracts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListContractsResponseValidationError{
						field:  fmt.Sprintf("Contracts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListContractsResponseValidationError{
					field:  fmt.Sprintf("Contracts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListContractsResponseMultiError(errors)
	}

	return nil
}

// ListContractsResponseMultiError is an error wrapping multiple validation
// errors returned by ListContractsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListContractsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListContractsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListContractsResponseMultiError) AllErrors() []error { return m }

// ListContractsResponseValidationError is the validation error returned by
// ListContractsResponse.Validate if the designated constraints aren't met.
type ListContractsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListContractsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListContractsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListContractsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListContractsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListContractsResponseValidationError) ErrorName() string {
	return "ListContractsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListContractsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListContractsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListContractsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListContractsResponseValidationError{}

// Validate checks the field values on DeleteContractRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteContractRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteContractRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteContractRequestMultiError, or nil if none found.
func (m *DeleteContractRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteContractRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteContractRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteContractRequestMultiError(errors)
	}

	return nil
}

// DeleteContractRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteContractRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteContractRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteContractRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteContractRequestMultiError) AllErrors() []error { return m }

// DeleteContractRequestValidationError is the validation error returned by
// DeleteContractRequest.Validate if the designated constraints aren't met.
type DeleteContractRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteContractRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteContractRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteContractRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteContractRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteContractRequestValidationError) ErrorName() string {
	return "DeleteContractRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteContractRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteContractRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteContractRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteContractRequestValidationError{}

// Validate checks the field values on Organization with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Organization) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Organization with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrganizationMultiError, or
// nil if none found.
func (m *Organization) ValidateAll() error {
	return m.validate(true)
}

func (m *Organization) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Industry

	// no validation rules for Region

	// no validation rules for Description

	// no validation rules for ProfileData

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrganizationValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrganizationValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrganizationValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrganizationValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrganizationMultiError(errors)
	}

	return nil
}

// OrganizationMultiError is an error wrapping multiple validation errors
// returned by Organization.ValidateAll() if the designated constraints aren't met.
type OrganizationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrganizationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrganizationMultiError) AllErrors() []error { return m }

// OrganizationValidationError is the validation error returned by
// Organization.Validate if the designated constraints aren't met.
type OrganizationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrganizationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrganizationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrganizationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrganizationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrganizationValidationError) ErrorName() string { return "OrganizationValidationError" }

// Error satisfies the builtin error interface
func (e OrganizationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrganization.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrganizationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrganizationValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for Email

	// no validation rules for TelegramId

	// no validation rules for FirstName

	// no validation rules for LastName

	// no validation rules for Role

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on Document with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Document) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Document with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentMultiError, or nil
// if none found.
func (m *Document) ValidateAll() error {
	return m.validate(true)
}

func (m *Document) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for Name

	// no validation rules for S3Key

	// no validation rules for FileType

	// no validation rules for FileSize

	// no validation rules for Status

	// no validation rules for ErrorMessage

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentMultiError(errors)
	}

	return nil
}

// DocumentMultiError is an error wrapping multiple validation errors returned
// by Document.ValidateAll() if the designated constraints aren't met.
type DocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMultiError) AllErrors() []error { return m }

// DocumentValidationError is the validation error returned by
// Document.Validate if the designated constraints aren't met.
type DocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentValidationError) ErrorName() string { return "DocumentValidationError" }

// Error satisfies the builtin error interface
func (e DocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentValidationError{}

// Validate checks the field values on Note with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Note) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Note with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NoteMultiError, or nil if none found.
func (m *Note) ValidateAll() error {
	return m.validate(true)
}

func (m *Note) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoteValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NoteMultiError(errors)
	}

	return nil
}

// NoteMultiError is an error wrapping multiple validation errors returned by
// Note.ValidateAll() if the designated constraints aren't met.
type NoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoteMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoteMultiError) AllErrors() []error { return m }

// NoteValidationError is the validation error returned by Note.Validate if the
// designated constraints aren't met.
type NoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoteValidationError) ErrorName() string { return "NoteValidationError" }

// Error satisfies the builtin error interface
func (e NoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoteValidationError{}

// Validate checks the field values on ContractTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContractTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContractTemplate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContractTemplateMultiError, or nil if none found.
func (m *ContractTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *ContractTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for TemplateType

	// no validation rules for FieldsSchema

	// no validation rules for S3TemplateKey

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractTemplateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractTemplateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractTemplateValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContractTemplateValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContractTemplateValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContractTemplateValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContractTemplateMultiError(errors)
	}

	return nil
}

// ContractTemplateMultiError is an error wrapping multiple validation errors
// returned by ContractTemplate.ValidateAll() if the designated constraints
// aren't met.
type ContractTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContractTemplateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContractTemplateMultiError) AllErrors() []error { return m }

// ContractTemplateValidationError is the validation error returned by
// ContractTemplate.Validate if the designated constraints aren't met.
type ContractTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContractTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContractTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContractTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContractTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContractTemplateValidationError) ErrorName() string { return "ContractTemplateValidationError" }

// Error satisfies the builtin error interface
func (e ContractTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContractTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContractTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContractTemplateValidationError{}

// Validate checks the field values on GeneratedContract with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GeneratedContract) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeneratedContract with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GeneratedContractMultiError, or nil if none found.
func (m *GeneratedContract) ValidateAll() error {
	return m.validate(true)
}

func (m *GeneratedContract) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OrganizationId

	// no validation rules for TemplateId

	// no validation rules for Name

	// no validation rules for FilledData

	// no validation rules for S3Key

	// no validation rules for FileType

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GeneratedContractValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GeneratedContractValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GeneratedContractValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GeneratedContractMultiError(errors)
	}

	return nil
}

// GeneratedContractMultiError is an error wrapping multiple validation errors
// returned by GeneratedContract.ValidateAll() if the designated constraints
// aren't met.
type GeneratedContractMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeneratedContractMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeneratedContractMultiError) AllErrors() []error { return m }

// GeneratedContractValidationError is the validation error returned by
// GeneratedContract.Validate if the designated constraints aren't met.
type GeneratedContractValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeneratedContractValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeneratedContractValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeneratedContractValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeneratedContractValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeneratedContractValidationError) ErrorName() string {
	return "GeneratedContractValidationError"
}

// Error satisfies the builtin error interface
func (e GeneratedContractValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneratedContract.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeneratedContractValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeneratedContractValidationError{}

// Validate checks the field values on GenerateUploadURLRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateUploadURLRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateUploadURLRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateUploadURLRequestMultiError, or nil if none found.
func (m *GenerateUploadURLRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateUploadURLRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOrganizationId()) < 1 {
		err := GenerateUploadURLRequestValidationError{
			field:  "OrganizationId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFileName()); l < 1 || l > 255 {
		err := GenerateUploadURLRequestValidationError{
			field:  "FileName",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetContentType()); l < 1 || l > 100 {
		err := GenerateUploadURLRequestValidationError{
			field:  "ContentType",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GenerateUploadURLRequestMultiError(errors)
	}

	return nil
}

// GenerateUploadURLRequestMultiError is an error wrapping multiple validation
// errors returned by GenerateUploadURLRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateUploadURLRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateUploadURLRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateUploadURLRequestMultiError) AllErrors() []error { return m }

// GenerateUploadURLRequestValidationError is the validation error returned by
// GenerateUploadURLRequest.Validate if the designated constraints aren't met.
type GenerateUploadURLRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateUploadURLRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateUploadURLRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateUploadURLRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateUploadURLRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateUploadURLRequestValidationError) ErrorName() string {
	return "GenerateUploadURLRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateUploadURLRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateUploadURLRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateUploadURLRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateUploadURLRequestValidationError{}

// Validate checks the field values on GenerateUploadURLResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateUploadURLResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateUploadURLResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateUploadURLResponseMultiError, or nil if none found.
func (m *GenerateUploadURLResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateUploadURLResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UploadUrl

	// no validation rules for S3Key

	// no validation rules for ExpiresInSeconds

	if len(errors) > 0 {
		return GenerateUploadURLResponseMultiError(errors)
	}

	return nil
}

// GenerateUploadURLResponseMultiError is an error wrapping multiple validation
// errors returned by GenerateUploadURLResponse.ValidateAll() if the
// designated constraints aren't met.
type GenerateUploadURLResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateUploadURLResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateUploadURLResponseMultiError) AllErrors() []error { return m }

// GenerateUploadURLResponseValidationError is the validation error returned by
// GenerateUploadURLResponse.Validate if the designated constraints aren't met.
type GenerateUploadURLResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateUploadURLResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateUploadURLResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateUploadURLResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateUploadURLResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateUploadURLResponseValidationError) ErrorName() string {
	return "GenerateUploadURLResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateUploadURLResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateUploadURLResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateUploadURLResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateUploadURLResponseValidationError{}

// Validate checks the field values on GenerateDownloadURLRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDownloadURLRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDownloadURLRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateDownloadURLRequestMultiError, or nil if none found.
func (m *GenerateDownloadURLRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDownloadURLRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetS3Key()) < 1 {
		err := GenerateDownloadURLRequestValidationError{
			field:  "S3Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GenerateDownloadURLRequestMultiError(errors)
	}

	return nil
}

// GenerateDownloadURLRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateDownloadURLRequest.ValidateAll() if
// the designated constraints aren't met.
type GenerateDownloadURLRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDownloadURLRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDownloadURLRequestMultiError) AllErrors() []error { return m }

// GenerateDownloadURLRequestValidationError is the validation error returned
// by GenerateDownloadURLRequest.Validate if the designated constraints aren't met.
type GenerateDownloadURLRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDownloadURLRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDownloadURLRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDownloadURLRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDownloadURLRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDownloadURLRequestValidationError) ErrorName() string {
	return "GenerateDownloadURLRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDownloadURLRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDownloadURLRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDownloadURLRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDownloadURLRequestValidationError{}

// Validate checks the field values on GenerateDownloadURLResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDownloadURLResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDownloadURLResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateDownloadURLResponseMultiError, or nil if none found.
func (m *GenerateDownloadURLResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDownloadURLResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DownloadUrl

	// no validation rules for ExpiresInSeconds

	if len(errors) > 0 {
		return GenerateDownloadURLResponseMultiError(errors)
	}

	return nil
}

// GenerateDownloadURLResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateDownloadURLResponse.ValidateAll() if
// the designated constraints aren't met.
type GenerateDownloadURLResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDownloadURLResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDownloadURLResponseMultiError) AllErrors() []error { return m }

// GenerateDownloadURLResponseValidationError is the validation error returned
// by GenerateDownloadURLResponse.Validate if the designated constraints
// aren't met.
type GenerateDownloadURLResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDownloadURLResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDownloadURLResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDownloadURLResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDownloadURLResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDownloadURLResponseValidationError) ErrorName() string {
	return "GenerateDownloadURLResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDownloadURLResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDownloadURLResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDownloadURLResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDownloadURLResponseValidationError{}
